(import (euler))

(define (e351-v0 L)
  (define L/2 (quotient L 2))
  (define h (- L 1))
  (do ((x 1 (1+ x)))
      ((<= L/2 x) (* 6 h))
    (do ((y 1 (1+ y)))
        ((< L/2 (+ x y)))
      (when (coprime? x y)
        (set! h (+ h (1- (quotient L (+ x y)))))))))

(define (e351-v1 L)
  (define L/2 (quotient L 2))
  (define h (+ L L/2 -2))
  (do ((x 1 (1+ x)))
      ((<= L/2 x) (* 6 h))
    (do ((y 1 (1+ y)))
        ((or (= x y) (< L/2 (+ x y))))
      (when (coprime? x y)
        ;; (display-ln (list x y (1- (quotient L (+ x y)))))
        (set! h (+ h (* 2 (1- (quotient L (+ x y))))))))))

(define (blocked L n)
  (1- (quotient L n)))

(define (e351-v2 L)
  (define T (totient-sieve (quotient L 2)))
  (define h (1- (quotient L 2)))
  (do ((n 1 (1+ n)))
      ((<= (quotient L 2) n) (* 6 h))
    ;;     (display-ln (list n h (fxvector-ref T n)))
    (set! h (+ h (* (fxvector-ref T n)
                    (blocked L n))))))

(define (e351 L)
  (define T (totient-sieve (1+ L)))
  (do ((n 1 (1+ n))
       (s 0 (+ s n (- (fxvector-ref T n)))))
      ((< L n) (* 6 s))))

(define (testy L)
  (let ((v1 (e351-v1 L))
        (v2 (e351-v2 L)))
    (display-ln (list L v1 v2 (- v1 v2)))))

(define (writey L)
  (delete-file "writey")
  (with-output-to-file "writey"
    (lambda ()
      (for-all (lambda (l)
                 (let ((v1 (e351-v1 l))
                       (v2 (e351-v2 l)))
                   (display-ln (- v1 v2))))
               (iota L)))))

(define (pairs L)
  (define h 0)
  (do ((x 1 (1+ x)))
      ((= x L) h)
    (when (coprime? x (- L x))
      (display-ln (cons x (- L x)))
      (inc! h))))

